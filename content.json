[{"title":"python-test","date":"2018-10-24T01:33:33.000Z","path":"python-test.html","text":"此文摘自阮一峰JS教程 DOM 什么是DOM DOM与html， DOM与JavaScript的关系 DOM的结构是怎么样的 JS是如何操控DOM的 Node接口节点Node 节点是DOM的最小组成单位 nodeType nodeValue nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。 只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效 parentNode 对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment） replaceChild(newNode, oldNode) 替换节点 normalize： 清除空的文本节点并且合并相邻的文本节点 NodeList &amp;&amp; Htmlcollection 接口NodeList NodeList实例是一个类似数组的对象，它的成员是节点对象;通过以下方法可以得到NodeList实例。 Node.childNodes document.querySelectorAll()等节点搜索方法 NodeList实例很像数组，可以使用length属性和forEach方法。但是，它不是数组，不能使用pop或push之类数组特有的方法。 NodeList.prototype.keys(): 返回键名的遍历器 NodeList.prototype.values(): 返回键值的遍历器 NodeList.prototype.entries(): 返回同时包含键值和键名的遍历器 可以使用for...of来遍历遍历器对象 注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有Node.childNodes返回的是一个动态集合，其他的 NodeList 都是静态集合 12345678910111213141516171819202122document.body.childNodes instanceof NodeList // truevar children = document.body.childNodes;for (var i = 0; i &lt; children.length; i++) &#123; var item = children[i];&#125;var children = document.body.childNodes;children.length // 18document.body.appendChild(document.createElement('p'));children.length // 19var children = document.body.childNodes;for (var key of children.keys()) &#123; console.log(key);&#125;for (var entry of children.entries()) &#123; console.log(entry);&#125; HTMLcollection HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历 返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如document.links、docuement.forms、document.images等 HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中 如果元素节点有id或name属性，那么HTMLCollection实例上面，可以使用id属性或name属性引用该节点元素。如果没有对应的节点，则返回null HTMLCollection.prototype.length HTMLCollection.prototype.namedItem():namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点,如果没有对应的节点，则返回null. 1234567document.links instanceof HTMLCollection // true// HTML 代码如下// &lt;img id=\"pic\" src=\"http://example.com/foo.jpg\"&gt;var pic = document.getElementById('pic');document.images.pic === pic // truedocument.images.namedItem('pic') === pic // true","tags":[{"name":"Python test","slug":"Python-test","permalink":"http://www.yubing.info/tags/Python-test/"}]},{"title":"python基础之属性方法","date":"2018-06-07T15:58:29.000Z","path":"python基础之属性方法.html","text":"类属性和实例属性 类属性是 类对象 所拥有的属性,它被所有的类对象的实例对象所共有,在内存中只存在一个副本 对于公有的类属性在类外可以通过类对象和实例对象访问, 私有类属性不可以 123456789101112131415161718class People(object): address = '湖北' #公有的类属性 __country = 'china' #私有的类属性 def __init__(self): self.name = 'xiaowang' #实例属性 self.age = 20 #实例属性p = People()print(p.__country) #错误，不能在类外通过实例对象访问私有的类属性print(People.__country) #错误，不能在类外通过类对象访问私有的类属性p.age =12 #实例属性print(p.name) #正确 实例属性print(p.age) #正确 实例属性print(People.address) #正确 类对象访问类属性print(People.name) #错误 类对象无法访问实例属性p.address = '广东' #新建同名实例属性, 并不会更改同名类属性, 实例属性会屏蔽掉同名的类属性del p.address #删除实例属性People.address = '广东' # 类对象才会修改雷属性 如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性 类方法,实例方法和静态方法 类方法: 是类对象所拥有的方法，需要用修饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以cls作为第一个参数的名字，就最好用cls了），能够通过 实例对象和类对象 去访问 类方法还有一个用途就是可以对类属性进行修改 1234567891011121314151617class People(object): __country = 'china' # 私有类属性在类外部无法访问和修改 #类方法，用classmethod来进行修饰 @classmethod def getCountry(cls): return cls.__country @classmethod def setCountry(cls,country): cls.__country = country p = People() print p.getCountry() #可以用过实例对象引用 print People.getCountry() #可以通过类对象引用 p.setCountry('japan') print p.getCountry() print People.getCountry() 静态方法: 需要通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数 12345678class People(object): country = 'china' @staticmethod def getCountry(): #静态方法 return People.country print People.getCountry() 从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法；而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用 两者最明显的区别是:类方法必须有一个类对象参数,静态方法不需要任务参数 __init__ 和 __new__ 的区别: __new__在__init__之前执行 __new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 __new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类__new__出来的实例，或者直接是object的__new__出来的实例 __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值 __new__ 来实现单例模式 1234567class A(object): def __init__(self): print(\"这是 init 方法\") def __new__(cls): print(\"这是 new 方法\") return object.__new__(cls) 调用父类初始化方法的三种方式: 12345678class B(A): def __init__(self): # 调用父类的__init__方法1(python2) A.__init__(self) # 调用父类的__init__方法2 super(B,self).__init__() # 调用父类的__init__方法3 super().__init__() 单例模式 单例:确保某一个类只有一个实例,而且自行实例化并向整个系统提供这个实例,这个类称为单例类,单例模式是一种对象创建型模式 1234567891011121314class Single(object): __instance = None __first_init = False def __new__(cls): if not __instance: cls.__instance = object.__new__(cls) return cls.__instance def __init__(self, name, age): if not __first_init: self.name = name self.age = age Single.__first_init = True","tags":[{"name":"Python","slug":"Python","permalink":"http://www.yubing.info/tags/Python/"}]},{"title":"python中编码的那些事","date":"2018-05-07T18:54:13.000Z","path":"python中编码的那些事.html","text":"TODO 各种编码的区别 在Python中,编码分为文本编码,url编码和解释器编码 下面从这三个方面来对比Python2 与 Python3的区别 Python2中: Python2解释器默认编码为ASCII编码,使用python2时基本都用’utf-8’所以经常会出现下面这种错误,这是由于解释器编码问题导致 UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe4 in position 0 解决方案: 1234# coding=utf-8import sys reload(sys) sys.setdefaultencoding('utf-8') python2中文本编码,python2中字符串类型一种 str(非unicode) ,一种 unicode,不同编码格式字符串之间不能直接转码,需要先解码(encode(‘utf8’))到中间状态unicode,再decode(‘gbk’)到想要的编码格式 python2中url编码与python3差别不大,这个主要是依赖urllib库 python3中编码问题就简单很多了, 因为python3解释器默认为’utf-8’,基本没有解释器编码的问题烦恼 python3中文本编码也简单许多, 因为python3中的字符串一种str(默认为unicode类型), 一种为bytes类型,str由于默认为unicode,所以不同编码格式之间可以直接转码不需要切换到中间状态","tags":[{"name":"Python","slug":"Python","permalink":"http://www.yubing.info/tags/Python/"},{"name":"编码","slug":"编码","permalink":"http://www.yubing.info/tags/编码/"}]}]